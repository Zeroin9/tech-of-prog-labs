package com.company.zeroing.binarytree;

/**
 * Бинарное дерево. Это структура данных, где каждый объект является узлом.
 *  Каждый узел может иметь два узла-потомка: левый узел и правый узел.
 * <br>
 * <b>Основные правила дерева:</b>
 * <il>
 *     <ul><b>1.</b> Узлы можно сравнивать (например, по ключу)</ul>
 *     <ul><b>2.</b> Потомки слева - меньше чем предок</ul>
 *     <ul><b>3.</b> Потомки справа - больше чем предок</ul>
 * </il>
 * @param <V> ключ, объект способный к сравнению с ему подобными
 * @param <E> значение
 */
public interface BinaryTree<V extends Comparable, E> {

    /**
     * Добавление в дерево происходит по следующему принципу:
     *  бОльшие элементы добавляются справа, меньшие - слева.
     * Если места заняты, то необходимо смещаться ниже по дереву.
     * Если ключи во время прохода по дереву сравняются - просто заменить значение в узле.
     * @param key ключ
     * @param value значение
     * @throws NullPointerException если передаваемый ключ это null
     */
    void add(V key, E value) throws NullPointerException;

    /**
     * Удаление в дереве происходит по следующему принципу:
     * 1. Если у удаляемого узла нет детей, то просто очищаем ссылки на удаляемый узел у родительского узла
     * 2. Если у удаляемого узла нет правого узла - заменяем ссылки на удаляемый узел
     *  ссылками на левый узел удаляемого узла
     * 3. Если у удаляемого узла есть правый узел - заменяем ссылки на удаляемый узел
     *  ссылками на минимальный дочерний узел правого узла удаляемого узла (влево до упора)
     * @param key ключ
     * @return true если элемент удалён (был найден)
     * @throws NullPointerException если передаваемый ключ это null
     */
    boolean remove(V key) throws NullPointerException;

    /**
     * Получение значения по ключу
     * @param key ключ
     * @return значение (value) или null, если не найден ключ
     * @throws NullPointerException если передаваемый ключ это null
     */
    E get(V key) throws NullPointerException;

}
